<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>前端监控测试</title>
  </head>
  <body>
    <div id="uuy">1</div>
    <div class="xyz">2</div>
    <div class="name">3</div>
    <button>点我！</button>
    <button class="qwe">点我测试长任务！</button>
    <script>
      function getSelectors(path) {
        // 反转 + 过滤 + 映射 + 拼接
        return path
          .reverse()
          .filter((element) => {
            return element !== document && element !== window;
          })
          .map((element) => {
            console.log('element', element);
            console.log('element', element.nodeName);
            let selector = '';
            if (element.id) {
              return `${element.nodeName.toLowerCase()}#${element.id}`;
            } else if (
              element.className &&
              typeof element.className === 'string'
            ) {
              return `${element.nodeName.toLowerCase()}.${element.className}`;
            } else {
              selector = element.nodeName.toLowerCase();
            }
            return selector;
          })
          .join(' ');
      }

      function getSelectorsFromPathsOrTarget(pathsOrTarget) {
        if (Array.isArray(pathsOrTarget)) {
          return getSelectors(pathsOrTarget);
        } else {
          let path = [];
          while (pathsOrTarget) {
            path.push(pathsOrTarget);
            pathsOrTarget = pathsOrTarget.parentNode;
          }
          console.log(path);
          return getSelectors(path);
        }
      }

      const target = document.querySelectorAll('div')[0];
    </script>
    <script>
      // 全局监听未捕获的 Promise 错误
      window.addEventListener('unhandledrejection', (event) => {
        console.log('Unhandled Promise Rejection:', event);
      });

      new Promise(function () {
        throw new Error('Whoops!');
      }); // no catch to handle the error
    </script>
    <script>
      function injectXHR() {
        let XMLHttpRequest = window.XMLHttpRequest;
        let oldOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function (method, url, async) {
          // 把上报接口过滤掉
          if (!url.match(/logstores/) && !url.match(/sockjs/)) {
            this.logData = { method, url, async };
          }
          return oldOpen.apply(this, arguments);
        };
        let oldSend = XMLHttpRequest.prototype.send;
        XMLHttpRequest.prototype.send = function (body) {
          if (this.logData) {
            let startTime = Date.now();
            let handler = (type) => (event) => {
              // 持续时间
              let duration = Date.now() - startTime;
              let status = this.status;
              let statusText = this.statusText;
              const sendData = {
                kind: 'stability',
                type: 'xhr',
                eventType: type,
                pathname: this.logData.url,
                status: status + '-' + statusText, // 状态码
                duration,
                response: this.response ? JSON.parse(this.response) : '', // 响应体
                params: body || '', // 入参
              };
              console.log(sendData);
            };
            this.addEventListener('load', handler('load'), false);
            this.addEventListener('error', handler, false);
            this.addEventListener('abort', handler, false);
          }
          return oldSend.apply(this, arguments);
        };
      }

      injectXHR();
    </script>
    <script>
      const btn = document.querySelector('button');
      function sendData(data) {
        const XHR = new XMLHttpRequest();
        const FD = {
          name: 'zs',
          age: 10,
        };

        // 设置请求地址和方法
        XHR.open('GET', 'http://localhost:3000/api/data');

        // 发送这个 formData 对象，HTTP 请求头会自动设置
        XHR.send(FD);
      }

      btn.addEventListener('click', () => {
        sendData({ test: 'ok' });
      });
    </script>
    <script>
      function onload(callback) {
        if (document.readyState === 'complete') {
          callback();
        } else {
          window.addEventListener('load', callback);
        }
      }
      function blankScreen() {
        let wrapperElements = ['html', 'body', '#container', '.content'];
        let emptyPoints = 0;
        function getSelector(element) {
          const { id, className, nodeName } = element;
          if (id) {
            return '#' + id;
          } else if (className) {
            // 过滤空白符 + 拼接
            return (
              '.' +
              className
                .split(' ')
                .filter((item) => !!item)
                .join('.')
            );
          } else {
            return nodeName.toLowerCase();
          }
        }
        function isWrapper(element) {
          let selector = getSelector(element);
          if (wrapperElements.indexOf(selector) !== -1) {
            emptyPoints++;
          }
        }
        // 刚开始页面内容为空，等页面渲染完成，再去做判断
        onload(function () {
          let xElements, yElements;
          for (let i = 0; i < 9; i++) {
            xElements = document.elementsFromPoint(
              (window.innerWidth * i) / 10,
              window.innerHeight / 2
            );
            yElements = document.elementsFromPoint(
              window.innerWidth / 2,
              (window.innerHeight * i) / 10
            );
            isWrapper(xElements[0]);
            isWrapper(yElements[0]);
          }
          // 白屏
          if (emptyPoints > 0) {
            const centerElements = document.elementsFromPoint(
              window.innerWidth / 2,
              window.innerHeight / 2
            );
            console.log(
              'emptyPoints++++++++++++++',
              getSelector(centerElements[0])
            );
            const data = {
              kind: 'stability',
              type: 'blank',
              emptyPoints: emptyPoints + '',
              screen: window.screen.width + 'X' + window.screen.height,
              viewPoint: window.innerWidth + 'X' + window.innerHeight,
              selector: getSelector(centerElements[0]),
            };
            console.log(data);
          }
        });
      }

      // blankScreen();
    </script>
    <script>
      const formatTime = (time) => new Date(time).getTime();

      function timing() {
        let FMP, LCP;
        // 增加一个性能条目的观察者
        new PerformanceObserver((entryList, observer) => {
          const perfEntries = entryList.getEntries();

          FMP = perfEntries[0];
          observer.disconnect(); // 不再观察了
        }).observe({ entryTypes: ['element '] }); // 观察页面中有意义的元素
        // 增加一个性能条目的观察者
        new PerformanceObserver((entryList, observer) => {
          const perfEntries = entryList.getEntries();
          const lastEntry = perfEntries[perfEntries.length - 1];
          LCP = lastEntry;
          observer.disconnect(); // 不再观察了
        }).observe({ entryTypes: ['largest-contentful-paint'] }); // 观察页面中最大的元素

        // 刚开始页面内容为空，等页面渲染完成，再去做判断
        onload(function () {
          setTimeout(() => {
            const {
              fetchStart,
              connectStart,
              connectEnd,
              requestStart,
              responseStart,
              responseEnd,
              domLoading,
              domInteractive,
              domContentLoadedEventStart,
              domContentLoadedEventEnd,
              loadEventStart,
            } = window.performance.timing;
            // 发送时间指标
            const data = {
              kind: 'experience', // 用户体验指标
              type: 'timing', // 统计每个阶段的时间
              connectTime: connectEnd - connectStart, // TCP连接耗时
              ttfbTime: responseStart - requestStart, // 首字节到达时间
              responseTime: responseEnd - responseStart, // response响应耗时
              parseDOMTime: loadEventStart - domLoading, // DOM解析渲染的时间
              domContentLoadedTime:
                domContentLoadedEventEnd - domContentLoadedEventStart, // DOMContentLoaded事件回调耗时
              timeToInteractive: domInteractive - fetchStart, // 首次可交互时间
              loadTime: loadEventStart - fetchStart, // 完整的加载时间
            };
            console.log(data);
            // 发送性能指标
            let FP = performance.getEntriesByName('first-paint')[0];
            let FCP = performance.getEntriesByName('first-contentful-paint')[0];
            console.log('FP', FP);
            console.log('FCP', FCP);
            console.log('FMP', FMP);
            console.log('LCP', LCP);
            const data2 = {
              kind: 'experience',
              type: 'paint',
              firstPaint: FP ? formatTime(FP.startTime) : 0,
              firstContentPaint: FCP ? formatTime(FCP.startTime) : 0,
              firstMeaningfulPaint: FMP ? formatTime(FMP.startTime) : 0,
              largestContentfulPaint: LCP
                ? formatTime(LCP.renderTime || LCP.loadTime)
                : 0,
            };
            console.log(data2);
          }, 3000);
        });
      }

      // timing();
    </script>
    <script>
      let lastEvent;
      function getLastEvent() {
        ['click', 'touchstart', 'mousedown', 'keydown', 'mouseover'].forEach(
          (eventType) => {
            document.addEventListener(
              eventType,
              (event) => {
                lastEvent = event;
                console.log(lastEvent, event);
              },
              {
                capture: true, // 是在捕获阶段还是冒泡阶段执行
                passive: true, // 默认不阻止默认事件
              }
            );
          }
        );
      }
      // getLastEvent();
      function longTask() {
        new PerformanceObserver((entryList) => {
          entryList.getEntries().forEach((entry) => {
            if (entry.duration > 100) {
              console.log(lastEvent);
              requestIdleCallback(() => {
                const data = {
                  kind: 'experience',
                  type: 'longTask',
                  eventType: lastEvent.type,
                  startTime: formatTime(entry.startTime), // 开始时间
                  duration: formatTime(entry.duration), // 持续时间
                  selector: lastEvent
                    ? getSelectorsFromPathsOrTarget(
                        lastEvent.path || lastEvent.target
                      )
                    : '',
                };
                console.log(data);
              });
            }
          });
        }).observe({ entryTypes: ['longtask'] });
      }

      longTask();
    </script>
    <script>
      const qwe = document.getElementsByClassName('qwe')[0];

      qwe.addEventListener('click', function () {
        console.log('a');
        function a() {
          for (let i = 1; i < 1000000000; i++) {}
          console.log('b');
        }
        a();
      });
    </script>
  </body>
</html>
